# -*- coding: utf-8 -*-
"""Commons.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DnlVXRtSAtuINrS47QP4t_KuZhZLLHIb
"""

import numpy as np
from keras.datasets import mnist
from keras.utils import to_categorical

from dense import Dense
from convolutional import Convolutional
from reshape import Reshape
from activations import Softmax, Sigmoid
from losses import binary_cross_entropy, binary_cross_entropy_prime
from networks import train, predict

from activation import Activation

class ReLU(Activation):
    def __init__(self):
        def relu(x):
            return np.maximum(0, x)

        def relu_prime(x):
            return (x > 0).astype(float)

        super().__init__(relu, relu_prime)

def preprocess_data(x, y, limit=None):
    # Shuffle dataset
    indices = np.arange(len(x))
    np.random.shuffle(indices)

    if limit:
        indices = indices[:limit]

    x, y = x[indices], y[indices]

    # Reshape to match (channels, height, width)
    x = x.reshape(len(x), 1, 28, 28)
    x = x.astype("float32") / 255

    # One-hot encode labels (0-9 â†’ 10 classes)
    y = to_categorical(y, num_classes=10)
    y = y.reshape(len(y), 10, 1)

    return x, y

# Load MNIST data
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# Example: take all data
x_train, y_train = preprocess_data(x_train, y_train, 1000)
x_test, y_test = preprocess_data(x_test, y_test, 1000)

network = [
    Convolutional((1, 28, 28), 3, 5),
    Sigmoid(),
    Reshape((5, 26, 26), (5 * 26 * 26, 1)),
    Dense(5 * 26 * 26, 100),
    Sigmoid(),
    Dense(100, 10), # Changed output size to 10 to match the number of classes
    Sigmoid()
]

# train
train(
    network,
    binary_cross_entropy,
    binary_cross_entropy_prime,
    x_train,
    y_train,
    epochs=100,
    learning_rate=0.1
)

# test
for x, y in zip(x_test, y_test):
    output = predict(network, x)
    print(f"pred: {np.argmax(output)}, true: {np.argmax(y)}")

correct = 0
total = len(x_test)

for x, y in zip(x_test, y_test):
    output = predict(network, x)
    if np.argmax(output) == np.argmax(y):
        correct += 1

accuracy = correct / total
print(f"Accuracy: {accuracy * 100:.2f}%")

